import pygame
import math
import random 
import numpy as np

# Constants
PARTY_V = 50 * np.array([[0., 2.1, 2.1, 2.1], [2.1, 0., 2.1, 2.1], [2.1, 2.1, 0., 2.1], [2.1, 2.1, 2.1, 0.]])
PARTY_R = 0.5 * np.array([[0., 100., 100., 100.], [100., 0., 100., 100.], [100., 100., 0., 100.], [100., 100., 100., 0.]])

class Ped:
    def __init__(self, init_s, exp_s, v0, init_v, tau, U, R):
        """
        Initialize each pedestrians

        Input:
            init_s: np.1darray; initial location on map
            exp_s: np.1darray; the target location of this pedestrian
            v0: float; the expected velocity of that human
            init_v: np.1darray; initial velocity on the map
            tau: float; expected time to accelerate to expected velocity
            U: float; the obstacle potential energy level
            R: float; the influence range of obstacles
        """
        self.s = init_s
        self.exp_s = exp_s
        self.v0 = v0
        self.vmax = 1.2 * self.v0
        self.v = init_v
        self.tau = tau
        self.U = U
        self.R = R
        self.sight_angle = np.pi/2
        self.sight_const = 0.5

    def move(self, dist, V, R):
        """
        Move the pedestrian in a time step

        Input:
            dist: np.2darray; relative location of the pedestrians
            V: np.1darray; potential energy to other pedestrians
            R: np.1darray; influence range to other pedestrians
        """
        f = self.target_force() + self.repulsive_force(dist, V, R) + self.obstacle_force()
        self.v += f * tdiff
        norm_v = np.linalg.norm(self.v)
        if norm_v > self.vmax:
            self.v = self.v * self.vmax / norm_v
        self.s += self.v * tdiff
        
    def target_force(self):
        # force generated by the attraction from target
        e = (self.exp_s - self.s) / np.linalg.norm(self.exp_s - self.s)
        f = (self.v0 * e - self.v) / self.tau
        return f
    
    def obstacle_force(self):
        # force generated by the repulsion from target
        d = self.dist_obstacle()
        norm_d = np.linalg.norm(d)
        f = -self.U * d / norm_d * np.exp(- norm_d / self.R)
        return f

    def repulsive_force(self, other_dist, other_V, other_R):
        # force generated by the repulsion from other pedestrians
        d = np.linalg.norm(other_dist, axis = 1)
        const = - other_V * np.exp(-d / other_R) / d
        f = np.repeat(np.expand_dims(const, 1), 2, axis = 1) * other_dist

        # visualized domain tune
        e_v = self.v / np.linalg.norm(self.v)
        swp_f = np.swapaxes(f, 0, 1)
        swp_f = np.where(d * np.cos(self.sight_angle) < np.dot(other_dist, e_v), swp_f * self.sight_const, swp_f)
        f = np.swapaxes(swp_f, 0, 1)

        return np.sum(f, axis = 0)

    def attraction_force(self, friend_dis):
        # force generated by the attraction from other pedestrians
        pass

    def dist_obstacle(self):
        """
        Return the closest vector distance to obstacles (only specify in this case)
        """
        if self.s[1] - 100 < 500 - self.s[1]:
            return np.array([0., 100. - self.s[1]])
        if self.s[1] - 100 > 500 - self.s[1]:
            return np.array([0., 500. - self.s[1]])
        return np.array([100000, 100000])

    def display(self):
        # display the pedestrian on the screen
        pygame.draw.circle(screen, (0,0,0), (int(self.s[0]), int(self.s[1])), 1, 0)
        pass


class Obstacle:
    def __init__(self, start, end):
        """
        Define the location of the obstacle (now only for visualization)
        each obstacle is just a line

        Input:
            start: np.1darray; the start point on the map
            end: np.1darray; the end point on the map
        """
        self.start = start
        self.end = end

    def display(self):
        # display the obstacle on the screen
        pygame.draw.line(screen, (0,0,0), (int(self.start[0]), int(self.start[1])), (int(self.end[0]), int(self.end[1])), 3)



screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption('Pedestrian Simulation')
screen.fill((255, 255, 255))
clock = pygame.time.Clock()

fps = 50.
tdiff = 1 / fps

# setup obstacles
obstacles = []
start = np.array([0, 100])
end = np.array([800,100])
obstacles.append(Obstacle(start, end))
start = np.array([0, 500])
end = np.array([800, 500])
obstacles.append(Obstacle(start, end))



# setup pedestrians
pedestrians = []
init_s = np.array([100., 150.])
exp_s = np.array([900., 150.])
v0 = 100.
init_v = np.array([100., 0])
tau = 0.5
U = 100.
R = 500.
p = Ped(init_s, exp_s, v0, init_v, tau, U, R)
pedestrians.append(p)

init_s = np.array([100., 200.])
exp_s = np.array([900., 200.])
v0 = 100.
init_v = np.array([100., 0])
tau = 0.5
U = 100.
R = 500.
p = Ped(init_s, exp_s, v0, init_v, tau, U, R)
pedestrians.append(p)

init_s = np.array([100., 250.])
exp_s = np.array([900., 250.])
v0 = 100.
init_v = np.array([100., 0])
tau = 0.5
U = 100.
R = 500.
p = Ped(init_s, exp_s, v0, init_v, tau, U, R)
pedestrians.append(p)

init_s = np.array([100., 300.])
exp_s = np.array([900., 300.])
v0 = 100.
init_v = np.array([100., 0])
tau = 0.5
U = 100.
R = 500.
p = Ped(init_s, exp_s, v0, init_v, tau, U, R)
pedestrians.append(p)
ped_num = len(pedestrians)


running = True
while running:
    clock.tick(fps)
    screen.fill((255,255,255))

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # display obstacles
    for obs in obstacles:
        obs.display()

    # relative distance matrix to all pedestians
    s = pedestrians[0].s
    repeat = np.expand_dims(np.tile(s, (ped_num,1)), axis = 0)
    for pid in range(1, ped_num):
        s = pedestrians[pid].s
        r = np.expand_dims(np.tile(s, (ped_num,1)), axis = 0)
        repeat = np.concatenate((repeat, r))
    dist_matr = np.swapaxes(repeat, 0, 1) - repeat
    

    # update pedestrians and display them
    for pid in range(ped_num):
        # relative information to other pedestrians
        other_dis = np.delete(dist_matr[pid], pid, 0)
        other_V = np.delete(PARTY_V[pid], pid, 0)
        other_R = np.delete(PARTY_R[pid], pid, 0)

        pedestrians[pid].move(other_dis, other_V, other_R)
        pedestrians[pid].display()

    pygame.display.flip()
